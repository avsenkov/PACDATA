<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>PACDATA — формы прототипа</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Bootstrap (для общей типографики) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"
        integrity="sha384-xOolHFLEh07PJGoPkLv1IbcEPTNtaed2xpHsD9ESMhqIYd0nLMwNLD69Npy4HI+N" crossorigin="anonymous">

  <!-- AG Grid (CDN) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ag-grid-community@34.1.1/styles/ag-grid.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ag-grid-community@34.1.1/styles/ag-theme-quartz.min.css">
  <script src="https://cdn.jsdelivr.net/npm/ag-grid-community@34.1.1/dist/ag-grid-community.min.js"></script>

  <!-- React + ReactDOM (UMD) -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>

  <!-- rjsf v4 (UMD) -->
  <script src="https://unpkg.com/@rjsf/core@4.2.2/dist/react-jsonschema-form.js"></script>
  <!-- Chart.js (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>

  <style>
    body { padding: 24px; }
    .wrap { max-width: 1100px; margin: 0 auto; }
    .actions { display: flex; gap: 8px; justify-content: flex-end; margin-top: 12px; }

    /* компактнее поля формы rjsf */
    .form-group { margin-bottom: .5rem; }

    /* AG Grid: читаемая высота строк и авто-высота контейнера */
    .ag-theme-quartz {
      --ag-font-size: 20px;
      --ag-grid-size: 40px;
      --ag-row-height: 60px;
      --ag-header-height: 60px;
        font-family: inherit; /* тот же шрифт, что у <body> */
        font-size: 1rem;      /* либо тот же, что у .form-control */
        line-height: 1.5;
    }
    .ag-theme-quartz .ag-root-wrapper { border: 1px solid #dee2e6; border-radius: .25rem; }
    .custom-grid-header {
        font-family: inherit;
        font-size: 1rem;
        line-height: 1.5;
        }
    /* Контейнер секций-таблиц */
    #tables { margin-top: 24px; }
    .grid-section { margin-bottom: 16px; }
    .grid-head { display:flex; align-items:center; justify-content:space-between; margin: 0 0 8px; }
  </style>
  <link rel="icon" href="data:,">
</head>
<body>
  <div class="wrap">
    <div class="d-flex align-items-center gap-3 mb-3">
      <h3 class="m-0">Формы</h3>
      <select id="formSelect" class="form-select" style="max-width: 320px;"></select>
      <button id="reloadBtn" class="btn btn-outline-secondary btn-sm">Перезагрузить</button>
    </div>
    <div id="title" class="text-muted mb-2"></div>

    <!-- RJSF-форма (только скалярные поля: строки/числа/даты/селекты) -->
    <div id="app"></div>
    <div id="charts" class="mb-3"></div>

    <!-- Таблицы для всех отношений 1→N -->
    <div id="tables"></div>
  </div>

  <script>
  (function () {
    // rjsf v4 UMD
    const RJSF = window.JSONSchemaForm || window.RJSFCore || window.RJSF;
    const Form = RJSF && (RJSF.default || RJSF);
    if (!Form) { document.getElementById('app').innerHTML = '<div class="alert alert-danger">Не удалось загрузить rjsf</div>'; return; }

    const DefaultArrayFieldTemplate = Form.defaultProps && Form.defaultProps.templates && Form.defaultProps.templates.ArrayFieldTemplate;

    function TabArrayFieldTemplate(props){
      const opts = (props.uiSchema && props.uiSchema['ui:options']) || {};
      if (!opts.tabs || !DefaultArrayFieldTemplate) {
        return React.createElement(DefaultArrayFieldTemplate || React.Fragment, props);
      }
      const { items, canAdd, onAddClick, formData } = props;
      const [active, setActive] = React.useState(0);
      const titleField = opts.tabNameField;
      function tabLabel(i){
        if (titleField && formData && formData[i] && formData[i][titleField]) return formData[i][titleField];
        return `Визит ${i+1}`;
      }
      return React.createElement('div', {},
        React.createElement('ul', { className:'nav nav-tabs mb-2' },
          items.map((item, i) =>
            React.createElement('li', { className:'nav-item', key:item.key },
              React.createElement('a', { href:'#', className:'nav-link'+(i===active?' active':''), onClick:e=>{e.preventDefault(); setActive(i);} }, tabLabel(i))
            )
          ).concat(canAdd ? [
            React.createElement('li', { className:'nav-item', key:'add' },
              React.createElement('button', { type:'button', className:'nav-link', onClick: ()=>{ onAddClick(); setActive(items.length); } }, '+')
            )
          ] : [])
        ),
        items.map((item,i)=>
          React.createElement('div', { key:item.key, style:{ display: i===active?'block':'none', border:'1px solid #dee2e6', borderTop:'none', padding:'10px' } },
            [
              item.children,
              item.hasRemove ? React.createElement('div',{className:'mt-2'},
                React.createElement('button',{type:'button',className:'btn btn-outline-danger btn-sm', onClick:item.onDropIndexClick(item.index)},'Удалить визит')
              ) : null
            ]
          )
        )
      );
    }

    // === Конфиг списка форм (соответствует структуре ./forms/<key>/) ===
    const FORMS = [
      { key: 'user',              label: 'Пользователь' },
      { key: 'patient',           label: 'Пациент' },
      { key: 'patient_with_visits', label: 'Визиты' },
      { key: 'visit',             label: 'Визит' },
      { key: 'hospital_test',     label: 'Больничный анализ' },
      { key: 'lab_genetics',      label: 'Лаборатория — генетика' },
      { key: 'lab_concentration', label: 'Лаборатория — концентрация ЛП' },
      { key: 'lab_phenotyping',   label: 'Лаборатория — фенотипирование' },
      { key: 'lab_microrna',      label: 'Лаборатория — микроРНК' }
    ];

    // === DOM ===
    const selectEl = document.getElementById('formSelect');
    selectEl.innerHTML = FORMS.map(f=>`<option value="${f.key}">${f.label}</option>`).join('');
    if (!selectEl.value) selectEl.value = 'visit';

    const titleEl  = document.getElementById('title');
    const appEl    = document.getElementById('app');
    const chartsEl = document.getElementById('charts');
    const tablesEl = document.getElementById('tables');

    // === helpers ===
    async function loadJSON(p){ const r=await fetch(p,{cache:'no-store'}); if(!r.ok) throw new Error(`${r.status} ${r.statusText}: ${p}`); return r.json(); }
    const base = (name)=>`./forms/${name}/`;

    // Утилиты для чтения enum/oneOf
    function enumSpec(prop){
      if (!prop) return null;
      if (Array.isArray(prop.enum)) {
        const ids = prop.enum.slice();
        const names = Array.isArray(prop.enumNames) ? prop.enumNames.slice() : ids.map(String);
        const map = {}; ids.forEach((v,i)=> map[String(v)] = names[i] ?? String(v));
        return { values: ids.map(String), map };
      }
      if (Array.isArray(prop.oneOf)) {
        const ids = prop.oneOf.map(o=> String(o.const));
        const map = {}; prop.oneOf.forEach(o=> map[String(o.const)] = o.title ?? String(o.const));
        return { values: ids, map };
      }
      return null;
    }

    // Разделяем схему: скалярные свойства -> в rjsf, массивы -> в AG Grid
    function splitSchema(schema, uiSchema){
      const base = JSON.parse(JSON.stringify(schema||{}));
      const arrays = [];
      if (base && base.properties){
        for (const [key, prop] of Object.entries(base.properties)){
          if (prop && prop.type === 'array' && prop.items && (prop.items.type === 'object' || prop.items.properties)){
            const ui = uiSchema && uiSchema[key];
            const useTabs = ui && ui['ui:options'] && ui['ui:options'].tabs;
            arrays.push({ key, title: prop.title || key, schema: prop, uiSchema: ui || {}, useTabs });
          }
        }
        // удалить массивы из rjsf-схемы
        arrays.forEach(a => delete base.properties[a.key]);
        if (Array.isArray(base.required)) base.required = base.required.filter(k => !arrays.find(a=>a.key===k));
      }
      return { baseSchema: base, arrays };
    }

    // Генерация колонок AG Grid из схемы items.properties
    function columnsFromItemProps(props){
      const cols = [];
      for (const [field, p] of Object.entries(props||{})){
        // пропускаем вложенные массивы — обработаем отдельно (flatten)
        if (p.type === 'array') continue;
        const es = enumSpec(p);
        if (es){
          cols.push({
            field, headerName: p.title || field, editable: true,
            cellEditor: 'agSelectCellEditor', cellEditorParams: { values: es.values },
            valueFormatter: (x)=> es.map[String(x.value)] || '',
            valueParser: (x)=> x.newValue
          });
          continue;
        }
        if (p.type === 'number' || p.type === 'integer'){
          cols.push({ field, headerName: p.title || field, editable: true,
            valueParser: (x)=> (x.newValue===''||isNaN(Number(x.newValue)))? null : (p.type==='integer'? parseInt(x.newValue,10): Number(x.newValue)) });
        } else {
          cols.push({ field, headerName: p.title || field, editable: true });
        }
      }
      // столбец действий
      cols.push({ headerName:'', width:110, flex:0, cellRenderer: p=>{ const b=document.createElement('button'); b.className='btn btn-sm btn-outline-danger'; b.textContent='Удалить'; b.onclick=()=>p.api.applyTransaction({remove:[p.node.data]}); return b; } });
      return cols;
    }

    // Построение спецификации таблицы для простого массива объектов
    function buildSimpleTableSpec(arrKey, arrSchema, initial){
      const itemProps = (arrSchema.items && arrSchema.items.properties) || {};
      const cols = columnsFromItemProps(itemProps);
      const blank = {}; for (const [f,p] of Object.entries(itemProps)) blank[f] = (p.type==='number'||p.type==='integer')? null : '';
      return { key: arrKey, title: arrSchema.title || arrKey, cols, rows: initial || [], blank, regroup: (rows)=> rows };
    }

    // Построение таблицы для случая «массив объектов, внутри один подмассив» (flatten)
    function buildFlattenTableSpec(arrKey, arrSchema, initial){
      const itemProps = (arrSchema.items && arrSchema.items.properties) || {};
      const subArrayEntry = Object.entries(itemProps).find(([k,p])=> p && p.type==='array' && p.items && p.items.properties);
      if (!subArrayEntry) return null;
      const [subKey, subSchema] = subArrayEntry; // например metabolites
      // поля родителя, кроме подмассива
      const parentFields = Object.fromEntries(Object.entries(itemProps).filter(([k,p])=> k!==subKey));
      // поля дочерних элементов
      const childFields  = (subSchema.items && subSchema.items.properties) || {};
      const cols = columnsFromItemProps({ ...{[arrKey+'_parent_marker']:{title:'',type:'string'}}, ...parentFields, ...childFields });
      // уберём служебный «маркер» из колонок
      cols.shift();

      // развернуть исходные данные в строки
      const rows = [];
      (initial||[]).forEach(parent => {
        const base = {}; Object.keys(parentFields).forEach(f=> base[f]= parent[f] ?? ((parentFields[f].type==='number'||parentFields[f].type==='integer')? null : ''));
        (parent[subKey]||[]).forEach(child => {
          const row = { ...base }; Object.keys(childFields).forEach(cf=> row[cf] = child[cf] ?? ((childFields[cf].type==='number'||childFields[cf].type==='integer')? null : ''));
          rows.push(row);
        });
        if ((parent[subKey]||[]).length===0) rows.push({ ...base });
      });

      const blank = {}; Object.assign(blank,
        ...Object.entries(parentFields).map(([f,p])=>({[f]:(p.type==='number'||p.type==='integer')? null:''})),
        ...Object.entries(childFields).map(([f,p])=>({[f]:(p.type==='number'||p.type==='integer')? null:''}))
      );

      // группировка обратно в исходную структуру
      function regroup(rows){
        const groupMap = new Map();
        function keyOf(r){ return JSON.stringify(Object.fromEntries(Object.keys(parentFields).map(k=>[k,r[k]??null]))); }
        rows.forEach(r=>{
          const k = keyOf(r);
          if (!groupMap.has(k)) groupMap.set(k,{ ...Object.fromEntries(Object.keys(parentFields).map(k2=>[k2,r[k2]??null])), [subKey]: [] });
          const child = Object.fromEntries(Object.keys(childFields).map(k3=>[k3, r[k3]??null]));
          // пропускаем полностью пустые дочерние
          const allEmpty = Object.values(child).every(v=> v===null || v==='');
          if (!allEmpty) groupMap.get(k)[subKey].push(child);
        });
        return Array.from(groupMap.values());
      }

      return { key: arrKey, title: arrSchema.title || arrKey, cols, rows, blank, regroup };
    }

    // Создать секцию-таблицу на странице и вернуть Grid API
    function mountGrid(sectionTitle, key, cols, rows, blankRow, container) {
  // создаём секцию с заголовком и контейнером грида
  const sec = document.createElement('div');
  sec.className = 'grid-section';
  sec.innerHTML = `
    <div class="grid-head" style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
      <h4 class="mb-0" style="font-family:inherit;font-weight:600;">${sectionTitle}</h4>
      <button class="btn btn-sm btn-success" id="btn-add-${key}">+ Добавить строку</button>
    </div>
    <div id="grid-${key}" class="ag-theme-quartz"></div>
  `;

  if (typeof tablesEl !== 'undefined') {
    (container || tablesEl).appendChild(sec);
  }

  const el = document.getElementById(`grid-${key}`);
  if (!el) return null;

  const api = agGrid.createGrid(el, {
    columnDefs: cols,
    rowData: rows || [],
    domLayout: 'autoHeight',
    rowHeight: 35,
    headerHeight: 35,
    defaultColDef: {
      resizable: true,
      sortable: true,
      flex: 1,
      minWidth: 140,
      cellStyle: {
        fontFamily: 'inherit',
        fontSize: '1rem',
        lineHeight: '1.5'
      },
      headerClass: 'custom-grid-header'
    },
    onFirstDataRendered: params => {
      if (params.api && typeof params.api.sizeColumnsToFit === 'function') {
        params.api.sizeColumnsToFit();
      }
    }
  });

  const addBtn = document.getElementById(`btn-add-${key}`);
  if (addBtn) addBtn.onclick = () => api.applyTransaction({ add: [ { ...(blankRow || {}) } ] });

  if (typeof api.sizeColumnsToFit === 'function') setTimeout(() => api.sizeColumnsToFit(), 0);

  if (!document.getElementById('custom-grid-header-style')) {
    const style = document.createElement('style');
    style.id = 'custom-grid-header-style';
    style.textContent = `
      .custom-grid-header {
        font-family: inherit !important;
        font-size: 1rem !important;
        line-height: 1.5 !important;
      }
    `;
    document.head.appendChild(style);
  }

  return api;
}


    function mountTabbedArray(sectionTitle, key, arrSchema, arrUi, initialData) {
      const sec = document.createElement('div');
      sec.className = 'grid-section';
      sec.innerHTML = `
        <div class="grid-head" style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
          <h4 class="mb-0" style="font-family:inherit;font-weight:600;">${sectionTitle}</h4>
          <button class="btn btn-sm btn-success" id="btn-add-${key}">+ Добавить визит</button>
        </div>
        <div id="tabs-${key}"></div>
      `;
      tablesEl.appendChild(sec);
      const tabsEl = document.getElementById(`tabs-${key}`);
      let active = 0;
      let data = Array.isArray(initialData) ? initialData.slice() : [];
      let records = [];

      function renderTabs(){

        if (records.length) data = records.map(r=> r.getData());

        records = [];
        tabsEl.innerHTML='';
        const nav = document.createElement('ul');
        nav.className = 'nav nav-tabs';
        tabsEl.appendChild(nav);
        const content = document.createElement('div');
        tabsEl.appendChild(content);

        data.forEach((d, idx)=>{
          const li = document.createElement('li');
          li.className = 'nav-item';
          const a = document.createElement('a');
          a.className = 'nav-link'+(idx===active?' active':'');
          a.href = '#';
          li.appendChild(a);
          nav.appendChild(li);
          a.onclick = e=>{ e.preventDefault(); active=idx; renderTabs(); };

          const pane = document.createElement('div');
          pane.style.display = idx===active?'block':'none';
          pane.style.border = '1px solid #dee2e6';
          pane.style.borderTop = 'none';
          pane.style.padding = '10px';
          content.appendChild(pane);

          const rec = renderVisitPane(pane, idx, d, a);
          records.push(rec);
        });
      }

      function renderVisitPane(pane, idx, d, anchor){
        let visitData = JSON.parse(JSON.stringify(d || {}));
        const innerSpecs = [];
        const innerApis = {};
        const { baseSchema: vBase, arrays: vArrays } = splitSchema(arrSchema.items, arrUi && arrUi.items);
        const formDiv = document.createElement('div');
        pane.appendChild(formDiv);
        function updateLabel(){
          const titleField = arrUi && arrUi['ui:options'] && arrUi['ui:options'].tabNameField;
          let label = `Визит ${idx+1}`;
          if (titleField && visitData && visitData[titleField]) label = visitData[titleField];
          anchor.textContent = label;
        }
        const onChange = ({formData})=>{ visitData = formData; updateLabel(); };
        ReactDOM.render(React.createElement(Form, { schema: vBase, uiSchema: arrUi && arrUi.items, formData: visitData, onChange }), formDiv);
        vArrays.forEach(vArr=>{
          const itemProps = (vArr.schema.items && vArr.schema.items.properties) || {};
          const hasOneSubArray = Object.values(itemProps).filter(p=> p && p.type==='array').length === 1;
          let spec;
          if (hasOneSubArray) spec = buildFlattenTableSpec(vArr.key, vArr.schema, visitData[vArr.key]);
          else spec = buildSimpleTableSpec(vArr.key, vArr.schema, visitData[vArr.key]);
          const gridKey = `${key}-${idx}-${vArr.key}`;
          const api = mountGrid(vArr.title || vArr.key, gridKey, spec.cols, spec.rows, spec.blank, pane);
          innerSpecs.push({ key: vArr.key, spec });
          innerApis[vArr.key] = api;
        });
        const removeBtn = document.createElement('button');
        removeBtn.type='button';
        removeBtn.className='btn btn-outline-danger btn-sm mt-2';
        removeBtn.textContent='Удалить визит';
        removeBtn.onclick = ()=>{
          data = records.map(r=> r.getData());
          data.splice(idx,1);
          if (active >= data.length) active = data.length-1;
          renderTabs();
        };
        pane.appendChild(removeBtn);
        updateLabel();
        return {
          getData: ()=>{
            const res = { ...visitData };
            innerSpecs.forEach(s=>{
              const rows=[];
              const api = innerApis[s.key];
              if (api) api.forEachNode(n=> rows.push({ ...n.data }));
              res[s.key] = s.spec.regroup ? s.spec.regroup(rows) : rows;
            });
            return res;
          }
        };
      }

      const addBtn = document.getElementById(`btn-add-${key}`);
      if (addBtn) addBtn.onclick = ()=>{ data = records.map(r=> r.getData()); data.push({}); active = data.length-1; renderTabs(); };

      renderTabs();

      return { getData: ()=> records.map(r=> r.getData()) };
    }


    // состояние спецификаций массивов текущей формы
    let arraySpecs = [];

    // Основной рендер
    async function render(name){
      try{
        // грузим json-описания
        const [schema, uiSchema, formData] = await Promise.all([
          loadJSON(base(name)+'schema.json'),
          loadJSON(base(name)+'uiSchema.json').catch(()=> ({})),
          loadJSON(base(name)+'formData.json').catch(()=> ({}))
        ]);

        // заголовок
        titleEl.textContent = (schema.title||name) + (schema.description? ' — '+schema.description : '');

        // делим схему: поля в rjsf, массивы в гриды
        const { baseSchema, arrays } = splitSchema(schema, uiSchema);

        // рендер rjsf
        const actions = React.createElement('div',{className:'actions'},
          React.createElement('button',{type:'submit',className:'btn btn-primary'},'Submit'),
          React.createElement('button',{type:'reset', className:'btn btn-outline-secondary'},'Reset')
        );
        const onSubmit = ({formData: scalarData})=>{
          const result = { ...scalarData };
          arraySpecs.forEach(s => { result[s.key] = s.getData(); });
          alert('Submitted:' + JSON.stringify(result, null, 2));
        };
        ReactDOM.render(React.createElement(Form, { schema: baseSchema, uiSchema, formData, templates:{ ArrayFieldTemplate: TabArrayFieldTemplate }, onSubmit }, actions), appEl);

        // Рендер графиков (между полями и таблицами)
        if (chartsEl) chartsEl.innerHTML = '';
        const chartDefs = (uiSchema && uiSchema['ui:charts']) || (formData && formData._charts) || [];
        if (chartsEl && Array.isArray(chartDefs) && chartDefs.length && window.Chart) {
          chartDefs.forEach((cfg, i) => {
            // Special mode: lab test series across visits with a selector
            if (cfg.type === 'lab_series') {
              const srcArrayKey = cfg.fromArray || 'visits';
              const xField = cfg.xField || 'visit_date';
              const nestedArray = cfg.nestedArray || 'hospital_tests';
              const nestedLabelField = cfg.nestedLabelField || 'name';
              const nestedValueField = cfg.nestedValueField || 'value_text';
              const selectLabel = cfg.selectLabel || 'Тип исследования';
              const title = cfg.title || 'Лабораторные исследования';
              const visits = (formData && formData[srcArrayKey]) || [];
              if (!Array.isArray(visits) || !visits.length) return;

              // Collect unique test names
              let names = [];
              visits.forEach(v => {
                const arr = (v && v[nestedArray]) || [];
                if (Array.isArray(arr)) arr.forEach(t => { const nm = t && t[nestedLabelField]; if (nm && !names.includes(nm)) names.push(nm); });
              });
              if (Array.isArray(cfg.includeNames) && cfg.includeNames.length) {
                names = names.filter(n => cfg.includeNames.includes(n));
              }
              if (!names.length) return;

              // Build container with selector and canvas
              const sec = document.createElement('div');
              sec.className = 'mb-3';
              sec.innerHTML = `
                <div class="d-flex align-items-center justify-content-between mb-2">
                  <h5 class="mb-0" style="font-weight:600;">${title}</h5>
                  <div class="form-inline">
                    <label class="mr-2" for="chart-sel-${i}">${selectLabel}:</label>
                    <select id="chart-sel-${i}" class="form-control form-control-sm"></select>
                  </div>
                </div>
                <div style="height:300px"><canvas id="chart-${i}"></canvas></div>
              `;
              chartsEl.appendChild(sec);
              const sel = sec.querySelector(`#chart-sel-${i}`);
              sel.innerHTML = names.map(n => `<option value="${n}">${n}</option>`).join('');
              const ctx = sec.querySelector(`#chart-${i}`);

              function seriesFor(name){
                const labels = visits.map(v => (v && v[xField] != null) ? String(v[xField]) : '');
                const data = visits.map(v => {
                  const arr = (v && v[nestedArray]) || [];
                  if (!Array.isArray(arr)) return null;
                  const rec = arr.find(t => t && t[nestedLabelField] === name);
                  if (!rec) return null;
                  const val = rec[nestedValueField];
                  let n;
                  if (typeof val === 'number') {
                    n = val;
                  } else if (typeof val === 'string') {
                    // Extract first numeric token, allow comma or dot decimals and optional leading minus
                    const m = val.match(/-?\d+(?:[.,]\d+)?/);
                    n = m ? Number(m[0].replace(',', '.')) : NaN;
                  } else {
                    n = Number(val);
                  }
                  return Number.isFinite(n) ? n : null;
                });
                return { labels, data };
              }

              const initial = sel.value || names[0];
              const ser = seriesFor(initial);
              let chart;
              try {
                chart = new Chart(ctx, {
                  type: 'line',
                  data: { labels: ser.labels, datasets: [{ label: initial, data: ser.data, fill: false, borderColor: '#3e95cd', backgroundColor: 'rgba(62,149,205,0.3)', tension: 0.2, pointRadius: 3 }] },
                  options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { position: 'top' } }, scales: { x: { ticks: { autoSkip: true, maxRotation: 0 } }, y: { beginAtZero: false } } }
                });
              } catch(e) { /* ignore chart errors */ }

              sel.onchange = () => {
                const name = sel.value;
                const s = seriesFor(name);
                if (chart) {
                  chart.data.labels = s.labels;
                  chart.data.datasets[0].label = name;
                  chart.data.datasets[0].data = s.data;
                  chart.update();
                }
              };

              return; // done with this chart cfg
            }

            // Default simple XY from a top-level array
            const type = cfg.type || 'line';
            const srcArrayKey = cfg.fromArray;
            const xField = cfg.xField;
            const yField = cfg.yField;
            const title = cfg.title || (cfg.yLabel || yField || 'Chart');
            const yLabel = cfg.yLabel || (yField || 'Value');
            if (!srcArrayKey || !xField || !yField) return;
            const src = (formData && formData[srcArrayKey]) || [];
            if (!Array.isArray(src) || !src.length) return;
            const labels = src.map(r => r && r[xField] != null ? String(r[xField]) : '');
            const data = src.map(r => {
              const v = r && r[yField];
              const n = (typeof v === 'number') ? v : Number(v);
              return isNaN(n) ? null : n;
            });
            const sec = document.createElement('div');
            sec.className = 'mb-3';
            sec.innerHTML = `<h5 class=\"mb-2\" style=\"font-weight:600;\">${title}</h5><div style=\"height:300px\"><canvas id=\"chart-${i}\"></canvas></div>`;
            chartsEl.appendChild(sec);
            const ctx = sec.querySelector(`#chart-${i}`);
            try{
              new Chart(ctx, {
                type,
                data: { labels, datasets: [{ label: yLabel, data, fill: false, borderColor: '#3e95cd', backgroundColor: 'rgba(62,149,205,0.3)', tension: 0.2, pointRadius: 3 }] },
                options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { position: 'top' }, title: { display: false } }, scales: { x: { ticks: { autoSkip: true, maxRotation: 0 } }, y: { beginAtZero: false } } }
              });
            } catch(e) { /* ignore chart errors */ }
          });
        }

        // отрисовать массивы
        tablesEl.innerHTML='';
        arraySpecs = [];

        for (const arr of arrays){
          if (arr.useTabs) {
            const spec = mountTabbedArray(arr.title || arr.key, arr.key, arr.schema, arr.uiSchema, formData[arr.key]);
            arraySpecs.push({ key: arr.key, getData: spec.getData });
            continue;
          }
          const itemProps = (arr.schema.items && arr.schema.items.properties) || {};
          const hasOneSubArray = Object.values(itemProps).filter(p=> p && p.type==='array').length === 1;
          let spec;
          if (hasOneSubArray) spec = buildFlattenTableSpec(arr.key, arr.schema, formData[arr.key]);
          else spec = buildSimpleTableSpec(arr.key, arr.schema, formData[arr.key]);
          const api = mountGrid(arr.title || arr.key, spec.key, spec.cols, spec.rows, spec.blank);
          arraySpecs.push({ key: spec.key, getData: () => {
            const list = [];
            if (api) api.forEachNode(n=> list.push({ ...n.data }));
            return spec.regroup(list);
          }});
        }
      } catch (e) {
        console.error(e);
        appEl.innerHTML = `<div class="alert alert-danger">${String(e)}</div>`;
        tablesEl.innerHTML='';
      }
    }

    document.getElementById('reloadBtn').onclick = ()=> render(selectEl.value);
    selectEl.onchange = ()=> render(selectEl.value);

    render(selectEl.value);
  })();
  </script>
</body>
</html>
